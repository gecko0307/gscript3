/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.vm;

import std.stdio;
import std.conv;
import std.variant;
import std.traits;
import std.algorithm;
import gscript.instruction_set;
import dlib.core.memory;
import dlib.container.dict;

class LabelMap
{
    private struct Entry
    {
        string key;
        size_t value;
        bool used;
        bool filled;
    }

    private Entry[] table;
    private size_t count;
    private size_t mask;

    this(size_t capacity)
    {
        size_t cap = 1;
        while (cap < capacity * 2) cap <<= 1;
        table = new Entry[cap];
        mask = cap - 1;
    }

    private size_t hash(string s) const
    {
        ulong h = 1469598103934665603UL;
        foreach (ubyte c; s) {
            h ^= c;
            h *= 1099511628211UL;
        }
        return cast(size_t)h;
    }

    void add(string key, size_t value)
    {
        if (count * 2 >= table.length) rehash();
        insert(key, value);
    }

    private void insert(string key, size_t value)
    {
        size_t i = hash(key) & mask;
        while (table[i].filled)
        {
            if (table[i].key == key)
            {
                table[i].value = value;
                return;
            }
            i = (i + 1) & mask;
        }
        table[i] = Entry(key, value, true, true);
        count++;
    }

    bool remove(string key)
    {
        size_t i = hash(key) & mask;
        while (table[i].used)
        {
            if (table[i].filled && table[i].key == key)
            {
                table[i].filled = false;
                count--;
                return true;
            }
            i = (i + 1) & mask;
        }
        return false;
    }

    size_t* opBinaryRight(string op: "in")(string key)
    {
        size_t i = hash(key) & mask;
        while (table[i].used) {
            if (table[i].filled && table[i].key == key)
                return &table[i].value;
            i = (i + 1) & mask;
        }
        return null;
    }

    size_t opIndex(string key)
    {
        auto p = key in this;
        if (!p) throw new Exception("Key not found: "~key);
        return *p;
    }
    
    size_t opIndexAssign(size_t v, string k)
    {
        add(k, v);
        return v;
    }

    private void rehash()
    {
        auto old = table;
        size_t cap = table.length * 2;
        table.length = cap;
        foreach (ref e; table) e = Entry.init;
        mask = cap - 1;
        count = 0;
        foreach (ref e; old)
        {
            if (e.filled)
                insert(e.key, e.value);
        }
    }
}

interface GsObject
{
    Variant get(string key);
    void set(string key, Variant value);
    bool contains(string key);
    GsObject dup();
}

class GsGCObject: GsObject
{
    protected:
    
    Variant[string] storage;
    
    public:
    
    this()
    {
    }

    Variant get(string key)
    {
        auto v = key in storage;
        if (v)
            return *v;
        else
        {
            auto proto = "__proto__" in storage;
            if (proto)
            {
                if (auto protoObj = proto.peek!GsObject)
                    return protoObj.get(key);
                else
                    return Variant(null);
            }
            else
                return Variant(null);
        }
    }

    void set(string key, Variant value)
    {
        storage[key] = value;
    }

    bool contains(string key)
    {
        if ((key in storage) !is null)
            return true;
        else
        {
            auto proto = "__proto__" in storage;
            if (proto)
            {
                if (auto protoObj = proto.peek!GsObject)
                    return protoObj.contains(key);
                else
                    return false;
            }
            else
                return false;
        }
    }
    
    GsObject dup()
    {
        GsGCObject newObj = new GsGCObject();
        foreach(key, value; storage)
        {
            newObj.set(key, value);
        }
        return newObj;
    }
}

alias GsNativeMethod = Variant delegate(Variant[]);
alias GsNativeFunc = Variant function(Variant[]);

struct GsCallFrame
{
    Variant[128] parameters;
    Variant[128] localVariables;
    size_t numParameters;
}

Variant vmBuiltinRemove(Variant[] args)
{
    if (args.length < 2)
        return args[0];
    
    if (args[0].peek!(Variant[]) is null)
        return args[0];
    
    auto arr = args[0].get!(Variant[]);
    if (arr.length == 0)
        return Variant(arr);
    
    auto removeIndex = cast(size_t)args[1].get!(double);
    auto newArr = new Variant[arr.length - 1];
    for (size_t i = 0; i < arr.length; i++)
    {
        if (i < removeIndex)
            newArr[i] = arr[i];
        else if (i > removeIndex)
            newArr[i - 1] = arr[i];
    }
    return Variant(newArr);
}

Variant vmBuiltinRemoveFront(Variant[] args)
{
    if (args[0].peek!(Variant[]) is null)
        return args[0];
    
    auto arr = args[0].get!(Variant[]);
    if (arr.length == 0)
        return Variant(arr);
    
    auto newArr = new Variant[arr.length - 1];
    for (size_t i = 1; i < arr.length; i++)
    {
        newArr[i - 1] = arr[i];
    }
    return Variant(newArr);
}

Variant vmBuiltinRemoveBack(Variant[] args)
{
    if (args[0].peek!(Variant[]) is null)
        return args[0];
    
    auto arr = args[0].get!(Variant[]);
    if (arr.length == 0)
        return Variant(arr);
    
    auto newArr = new Variant[arr.length - 1];
    for (size_t i = 0; i < newArr.length; i++)
    {
        newArr[i] = arr[i];
    }
    return Variant(newArr);
}

Variant vmBuiltinInsert(Variant[] args)
{
    if (args.length < 3)
        return args[0];
    
    if (args[0].peek!(Variant[]) is null)
        return args[0];
    
    auto arr = args[0].get!(Variant[]);
    auto insertIndex = cast(size_t)args[1].get!(double);
    if (insertIndex < 0)
        return args[0];
    
    auto value = args[2];
    
    auto newArr = new Variant[arr.length + 1];
    for (size_t i = 0; i < newArr.length; i++)
    {
        if (i < insertIndex)
            newArr[i] = arr[i];
        else if (i == insertIndex)
            newArr[i] = value;
        else
            newArr[i] = arr[i - 1];
    }
    return Variant(newArr);
}

class GsVirtualMachine: GsObject
{
  protected:
    Variant[] stack;
    GsInstruction[] instructions;
    size_t[] callStack;            // Call stack for subroutine return addresses
    GsCallFrame[] callFrames;      // Stack of call frames
    size_t ip;                     // Instruction pointer
    size_t sp;                     // Stack pointer
    size_t cp;                     // Call stack pointer

    LabelMap jumpTable;            // Function table mapping names to instruction indices
    Variant[string] globals;       // Built-in variables
    
  public:

    this()
    {
        this.stack = new Variant[256];          // Fixed stack size
        this.callStack = new size_t[256];       // Fixed call stack size
        this.callFrames = new GsCallFrame[256]; // Initialize empty call stack
        this.ip = 0;
        this.sp = 0;
        this.cp = 0;
        
        jumpTable = new LabelMap(1000000);
        
        set("remove", Variant(&vmBuiltinRemove));
        set("removeFront", Variant(&vmBuiltinRemoveFront));
        set("removeBack", Variant(&vmBuiltinRemoveBack));
        set("insert", Variant(&vmBuiltinInsert));
    }
    
    Variant get(string key)
    {
        auto v = key in globals;
        if (v)
            return *v;
        else
            return Variant(cast(double)0.0);
    }

    void set(string key, Variant value)
    {
        globals[key] = value;
    }

    bool contains(string key)
    {
        return (key in globals) !is null;
    }
    
    GsObject dup()
    {
        GsGCObject newObj = new GsGCObject();
        foreach(key, value; globals)
        {
            newObj.set(key, value);
        }
        return newObj;
    }

    // Stack manipulation methods
    Variant pop()
    {
        if (sp == 0)
        {
            throw new Exception("Stack underflow");
        }
        return stack[--sp];
    }

    Variant peek()
    {
        if (sp == 0)
        {
            throw new Exception("Stack is empty");
        }
        return stack[sp - 1];
    }

    void push(Variant value)
    {
        if (sp >= stack.length)
        {
            throw new Exception("Stack overflow");
        }
        stack[sp++] = value;
    }
    
    GsObject createObject()
    {
        return new GsGCObject();
    }
    
    Variant[] createArray(size_t len)
    {
        return new Variant[len];
    }
    
    bool hasLabel(string name)
    {
        return (name in jumpTable) != null;
    }

    void load(GsInstruction[] instructions)
    {
        if (instructions[$-1].type != GsInstructionType.HALT)
            this.instructions = instructions ~ GsInstruction(GsInstructionType.HALT);
        else
            this.instructions = instructions;
        
        // Populate the function table with label indices
        foreach(i, instrunction; instructions)
        {
            if (instrunction.type == GsInstructionType.LABEL)
            {
                jumpTable[instrunction.operand.get!string] = i;
            }
        }
        
        finalize();
    }
    
    void finalize()
    {
        ip = instructions.length - 1;
    }
    
    void run(size_t initialIp = 0)
    {
        ip = initialIp;
        sp = 0;
        cp = 0;
        GsCallFrame* callFrame = &callFrames[cp];
        
        while (ip < instructions.length)
        {
            auto instruction = instructions[ip++];
            //writeln(instruction);
            switch (instruction.type)
            {
                case GsInstructionType.LABEL:
                    break;
                case GsInstructionType.PUSH:
                    push(instruction.operand);
                    break;
                case GsInstructionType.POP:
                    pop();
                    break;
                case GsInstructionType.ADD:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double + b.get!double));
                    else
                    {
                        writefln("Fatality: addition of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.SUB:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double - b.get!double));
                    else
                    {
                        writefln("Fatality: subtraction of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.MUL:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double * b.get!double));
                    else
                    {
                        writefln("Fatality: multiplication of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.DIV:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double / b.get!double));
                    else
                    {
                        writefln("Fatality: division of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.NEG:
                    auto a = pop();
                    if (a.convertsTo!(double))
                        push(Variant(-a.get!double));
                    else
                    {
                        writefln("Fatality: negation of %s", a.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.MOD:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double % b.get!double));
                    else
                    {
                        writefln("Fatality: modulo of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.POW:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double ^^ b.get!double));
                    else
                    {
                        writefln("Fatality: power of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.BITWISE_AND:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(cast(long)(a.get!double) & cast(long)(b.get!double)));
                    else
                    {
                        writefln("Fatality: bitwise AND of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.BITWISE_OR:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(cast(long)(a.get!double) | cast(long)(b.get!double)));
                    else
                    {
                        writefln("Fatality: bitwise OR of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.BITWISE_XOR:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(cast(long)(a.get!double) ^ cast(long)(b.get!double)));
                    else
                    {
                        writefln("Fatality: bitwise XOR of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.AND:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double && b.get!double));
                    else
                    {
                        writefln("Fatality: logical AND of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.OR:
                    auto b = pop();
                    auto a = pop();
                    if (a.convertsTo!(double) && b.convertsTo!(double))
                        push(Variant(a.get!double || b.get!double));
                    else
                    {
                        writefln("Fatality: logical OR of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.NOT:
                    auto a = pop();
                    if (a.convertsTo!(double))
                        push(Variant(!a.get!double));
                    else
                    {
                        writefln("Fatality: logical NOT of %s", a.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.CAT:
                    auto b = pop();
                    auto a = pop();
                    if (a.type is typeid(string))
                    {
                        push(Variant(a.toString() ~ b.toString()));
                    }
                    else if (a.peek!(Variant[]) !is null)
                    {
                        auto arr = a.get!(Variant[]);
                        push(Variant(arr ~ b));
                    }
                    else
                    {
                        writefln("Fatality: illegal concatenation of %s and %s", a.type, b.type);
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.EQ:
                    auto b = pop();
                    auto a = pop();
                    push(Variant(a == b));
                    break;
                case GsInstructionType.LESS:
                    auto b = pop().get!double;
                    auto a = pop().get!double;
                    push(Variant(a < b));
                    break;
                case GsInstructionType.GREATER:
                    auto b = pop().get!double;
                    auto a = pop().get!double;
                    push(Variant(a > b));
                    break;
                case GsInstructionType.NEQ:
                    auto b = pop();
                    auto a = pop();
                    push(Variant(a != b));
                    break;
                case GsInstructionType.LESS_EQ:
                    auto b = pop().get!double;
                    auto a = pop().get!double;
                    push(Variant(a <= b));
                    break;
                case GsInstructionType.GREATER_EQ:
                    auto b = pop().get!double;
                    auto a = pop().get!double;
                    push(Variant(a >= b));
                    break;
                case GsInstructionType.JMP:
                    ip = jumpTable[instruction.operand.get!string];
                    break;
                case GsInstructionType.JMP_IF:
                    if (cast(bool)pop().get!double)
                        ip = jumpTable[instruction.operand.get!string];
                    break;
                case GsInstructionType.JMP_IF_NOT:
                    if (!cast(bool)pop().get!double)
                        ip = jumpTable[instruction.operand.get!string];
                    break;
                case GsInstructionType.INDEX_GET:
                    size_t index = cast(size_t)pop().get!double;
                    auto arrayParam = pop();
                    if (arrayParam.peek!(Variant[]) !is null)
                    {
                        auto array = arrayParam.get!(Variant[]);
                        if (index >= 0 && index < array.length)
                        {
                            push(array[index]);
                            break;
                        }
                        else
                        {
                            writeln("Fatality: index is outside array capability");
                            finalize();
                            return;
                        }
                    }
                    else
                    {
                        writefln("Fatality: attempting to index %s which is not an array", arrayParam.type);
                        finalize();
                        return;
                    }
                case GsInstructionType.INDEX_SET:
                    size_t index = cast(size_t)pop().get!double;
                    auto arrayParam = pop();
                    if (arrayParam.peek!(Variant[]) !is null)
                    {
                        auto array = arrayParam.get!(Variant[]);
                        auto value = pop();
                        if (index >= 0 && index < array.length)
                            array[index] = value;
                        else
                        {
                            writeln("Fatality: index is outside array capability");
                            finalize();
                            return;
                        }
                        push(value);
                        break;
                    }
                    else
                    {
                        writefln("Fatality: attempting to index %s which is not an array", arrayParam.type);
                        finalize();
                        return;
                    }
                case GsInstructionType.LENGTH:
                    auto array = pop();
                    push(Variant(cast(double)array.length));
                    break;
                case GsInstructionType.PRINT:
                    writeln(pop());
                    break;
                case GsInstructionType.GLOBAL:
                    push(Variant(cast(GsObject)this));
                    break;
                case GsInstructionType.ARRAY:
                    size_t len = cast(size_t)pop().get!double;
                    auto arr = createArray(len);
                    for (size_t i = 0; i < len; i++)
                    {
                        arr[$ - 1 - i] = pop();
                    }
                    push(Variant(arr));
                    break;
                case GsInstructionType.CALL:
                    size_t numParams = cast(size_t)instruction.operand.get!double;
                    
                    auto func = pop();
                    
                    GsNativeMethod nativeMethod;
                    GsNativeFunc nativeFuncPtr;
                    bool useNativeMethod = false;
                    bool useNativeFunc = false;
                    
                    if (func.type is typeid(GsNativeMethod))
                    {
                        nativeMethod = func.get!GsNativeMethod();
                        useNativeMethod = true;
                    }
                    else if (func.type is typeid(GsNativeFunc))
                    {
                        nativeFuncPtr = func.get!GsNativeFunc();
                        useNativeFunc = true;
                    }
                    else
                    {
                        if (func.type is typeid(string))
                        {
                            string funcName = func.get!string;
                            if (funcName in jumpTable)
                            {
                                callStack[cp] = ip; // Push the current instruction pointer onto the call stack
                                // Push a new call frame
                                cp++;
                                callFrame = &callFrames[cp];
                                for(size_t i = 0; i < callFrame.parameters.length; i++)
                                {
                                    if (i < numParams)
                                        callFrame.parameters[numParams - 1 - i] = pop();
                                    else
                                        callFrame.parameters[i] = Variant.init;
                                }
                                callFrame.numParameters = numParams;
                                
                                ip = jumpTable[funcName]; // Jump to the function's starting instruction
                                
                                break;
                            }
                            else if (funcName in globals)
                            {
                                auto nativeFunc = globals[funcName];
                                
                                if (nativeFunc.type is typeid(GsNativeMethod))
                                {
                                    nativeMethod = nativeFunc.get!GsNativeMethod();
                                    useNativeMethod = true;
                                }
                                else if (nativeFunc.type is typeid(GsNativeFunc))
                                {
                                    nativeFuncPtr = nativeFunc.get!GsNativeFunc();
                                    useNativeFunc = true;
                                }
                                else
                                {
                                    writeln("Fatality: unsupported native call for function \"%s\"", funcName);
                                    finalize();
                                    return;
                                }
                            }
                            else
                            {
                                writefln("Fatality: undefined jump label \"%s\"", funcName);
                                finalize();
                                return;
                            }
                        }
                        else
                        {
                            writefln("Fatality: attempting to call %s, which is not a function", func.type);
                            finalize();
                            return;
                        }
                    }
                    
                    // Native call: push a new call frame
                    cp++;
                    callFrame = &callFrames[cp];
                    for(size_t i = 0; i < callFrame.parameters.length; i++)
                    {
                        if (i < numParams)
                            callFrame.parameters[numParams - 1 - i] = pop();
                        else
                            callFrame.parameters[i] = Variant.init;
                    }
                    callFrame.numParameters = numParams;
                    
                    Variant result;
                    if (useNativeMethod)
                        result = nativeMethod(callFrame.parameters[0..numParams]);
                    else if (useNativeFunc)
                        result = nativeFuncPtr(callFrame.parameters[0..numParams]);
                    
                    cp--;
                    callFrame = &callFrames[cp];
                    push(result);
                    break;
                case GsInstructionType.RET:
                    cp--;
                    ip = callStack[cp]; // Pop the return address from the call stack
                    callFrame = &callFrames[cp];
                    break;
                case GsInstructionType.STORE_VAR:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    callFrames[cp].localVariables[vIndex] = peek(); // Store a value into a local variable
                    break;
                case GsInstructionType.LOAD_VAR:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    push(callFrames[cp].localVariables[vIndex]); // Load a local variable onto the stack
                    break;
                case GsInstructionType.STORE_ARG:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    callFrames[cp].parameters[vIndex] = peek(); // Store a stack value into a parameter
                    break;
                case GsInstructionType.LOAD_ARG:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    push(callFrames[cp].parameters[vIndex]); // Load a parameter onto the stack
                    break;
                case GsInstructionType.LOAD_ARGS:
                    auto frame = &callFrames[cp];
                    push(Variant(frame.parameters[0..frame.numParameters])); // Load all parameters onto the stack
                    break;
                case GsInstructionType.GLOBAL_STORE_VAR:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    callFrames[0].localVariables[vIndex] = peek(); // Store a value into a global variable
                    break;
                case GsInstructionType.GLOBAL_LOAD_VAR:
                    size_t vIndex = cast(size_t)instruction.operand.get!double;
                    push(callFrames[0].localVariables[vIndex]); // Load a global variable onto the stack
                    break;
                case GsInstructionType.NEW:
                    auto obj = createObject();
                    push(Variant(obj));
                    break;
                case GsInstructionType.REUSE:
                    auto param = pop();
                    if (auto obj = param.peek!(GsObject))
                    {
                        auto newObj = createObject();
                        newObj.set("__proto__", param);
                        push(Variant(newObj));
                    }
                    else
                    {
                        writeln("Fatality: attempting to reuse non-object");
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.GET:
                    auto key = instruction.operand.get!string;
                    auto param = pop();
                    if (auto obj = param.peek!(GsObject))
                    {
                        push(obj.get(key));
                    }
                    else
                    {
                        writeln("Fatality: attempting to read member \"", key, "\" of non-object");
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.SET:
                    auto key = instruction.operand.get!string;
                    auto param = pop();
                    auto value = pop();
                    if (auto obj = param.peek!(GsObject))
                    {
                        obj.set(key, value);
                        push(value);
                        break;
                    }
                    else
                    {
                        writeln("Fatality: attempting to write member \"", key, "\" of non-object");
                        finalize();
                        return;
                    }
                case GsInstructionType.INIT_SET:
                    auto key = instruction.operand.get!string;
                    auto value = pop();
                    auto param = peek();
                    if (auto obj = param.peek!(GsObject))
                    {
                        obj.set(key, value);
                        break;
                    }
                    else
                    {
                        writeln("Fatality: attempting to write member \"", key, "\" of non-object");
                        finalize();
                        return;
                    }
                case GsInstructionType.CONTAINS:
                    auto key = instruction.operand.get!string;
                    auto param = pop();
                    if (auto obj = param.peek!(GsObject))
                    {
                        push(Variant(obj.contains(key)));
                    }
                    else
                    {
                        writeln("Fatality: attempting to read member \"", key, "\" of non-object");
                        finalize();
                        return;
                    }
                    break;
                case GsInstructionType.HALT:
                    finalize();
                    return;
                default:
                    writeln("Fatality: unknown instruction: ", instruction.type);
                    finalize();
                    return;
            }
        }
        
        finalize();
    }
}
