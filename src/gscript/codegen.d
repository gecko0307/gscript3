/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.codegen;

import std.stdio;
import std.array;
import std.conv;
import std.algorithm;

import gscript.parser;
import gscript.instruction_set;
import gscript.dynamic;

class GsCodeGenerator
{
    GsInstructionType[string] binaryOperatorMap = [
        "+": GsInstructionType.ADD,
        "-": GsInstructionType.SUB,
        "*": GsInstructionType.MUL,
        "/": GsInstructionType.DIV,
        "%": GsInstructionType.MOD,
        "^^": GsInstructionType.POW,
        "&&": GsInstructionType.AND,
        "||": GsInstructionType.OR,
        "&": GsInstructionType.BITWISE_AND,
        "|": GsInstructionType.BITWISE_OR,
        "^": GsInstructionType.BITWISE_XOR,
        "~": GsInstructionType.CAT,
        "==": GsInstructionType.EQ,
        "!=": GsInstructionType.NEQ,
        "<": GsInstructionType.LESS,
        ">": GsInstructionType.GREATER,
        "<=": GsInstructionType.LESS_EQ,
        ">=": GsInstructionType.GREATER_EQ
    ];
    
    GsInstructionType[string] unaryOperatorMap = [
        "-": GsInstructionType.NEG,
        "!": GsInstructionType.NOT
    ];
    
    string[] builtins = [
        "remove", "removeFront", "removeBack", "insert"
    ];
    
    Scope globalScope;
    
    uint numLabels = 0;
    string getLabel()
    {
        return "label" ~ to!string(numLabels++);
    }
    
    this()
    {
    }
    
    protected GsInstruction[] generateLambdas(ASTNode node)
    {
        GsInstruction[] instructions;
        
        if (node.type == NodeType.FunctionLiteral)
        {
            auto func = cast(ASTFunctionLiteral)node;
            // TODO: qualified name
            instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(func.label));
            
            // Function body
            instructions ~= generate(func.bodyBlock);
            
            // Default return 0
            instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(cast(double)0.0));
            instructions ~= GsInstruction(GsInstructionType.RET);
        }
        else if (node.type == NodeType.Function)
        {
            auto func = cast(ASTFunction)node;
            
            auto instr = generateLambdas(func.bodyBlock);
            if (instr.length)
                instructions ~= instr;
        }
        else
        {
            foreach(child; node.children)
            {
                auto instr = generateLambdas(child);
                if (instr.length)
                    instructions ~= instr;
            }
        }
        
        return instructions;
    }
    
    protected GsInstruction[] generate(ASTNode node)
    {
        GsInstruction[] instructions;
        
        switch(node.type)
        {
            case NodeType.NumberLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value.to!double));
                break;
            
            case NodeType.StringLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value[1 .. $-1]));
                break;
            
            case NodeType.BooleanLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value.to!bool));
                break;
            
            case NodeType.ArrayLiteral:
                foreach(child; node.children)
                    instructions ~= generate(child);
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.children.length));
                instructions ~= GsInstruction(GsInstructionType.ARRAY);
                break;
            
            case NodeType.ObjectLiteral:
                instructions ~= GsInstruction(GsInstructionType.NEW);
                foreach(child; node.children)
                {
                    string key = child.value;
                    instructions ~= generate(child.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.INIT_SET, GsDynamic(key));
                }
                break;
            
            case NodeType.FunctionLiteral:
                auto func = cast(ASTFunctionLiteral)node;
                func.label = getLabel();
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.label));
                break;
            
            case NodeType.Identifier:
                string name = node.value;
                if (name == "global")
                {
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL);
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    int index = node.programScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, GsDynamic(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    int index = globalScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, GsDynamic(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.AssignExpression:
                ASTNode lhs = node.children[0];
                string name = lhs.value;
                ASTNode rhs = node.children[1];
                instructions ~= generate(rhs);
                if (lhs.type == NodeType.MemberPropertyAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // object
                    instructions ~= GsInstruction(GsInstructionType.SET, GsDynamic(name));
                }
                else if (lhs.type == NodeType.IndexAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // array
                    instructions ~= generate(lhs.children[1]); // index
                    instructions ~= GsInstruction(GsInstructionType.INDEX_SET);
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    GsVariable* v = node.programScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.STORE_VAR, GsDynamic(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.STORE_ARG, GsDynamic(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    GsVariable* v = globalScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_STORE_VAR, GsDynamic(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.BinaryExpression:
                string op = node.value;
                if (op == "&&")
                {
                    // Short-circuit for logical AND
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, GsDynamic(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.AND);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(label));
                }
                else if (op == "||")
                {
                    // Short-circuit for logical OR
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF, GsDynamic(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.OR);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(label));
                }
                else
                {
                    instructions ~= generate(node.children[0]);
                    instructions ~= generate(node.children[1]);
                    GsInstructionType* instrTypePtr = op in binaryOperatorMap;
                    if (instrTypePtr)
                        instructions ~= GsInstruction(*instrTypePtr);
                    else
                        throw new Exception("Unknown binary operator: " ~ op);
                }
                break;
            
            case NodeType.UnaryExpression:
                string op = node.value;
                auto operand = node.children[0];
                instructions ~= generate(operand);
                if (op != "+") // unary plus is a no-op
                {
                    GsInstructionType* instrTypePtr = op in unaryOperatorMap;
                    if (instrTypePtr)
                        instructions ~= GsInstruction(*instrTypePtr);
                    else
                        throw new Exception("Unknown unary operator: " ~ op);
                }
                break;
            
            case NodeType.FunctionCallExpression:
                // TODO: qualified name
                string funcName = node.value;
                size_t numParameters = node.children.length;
                foreach(child; node.children)
                    instructions ~= generate(child);
                if (node.programScope.isVariableVisible(funcName))
                {
                    // Call by reference
                    int index = node.programScope.variableIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, GsDynamic(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(funcName))
                {
                    // Call by reference
                    int index = node.programScope.argumentIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(cast(double)index));
                }
                else if (globalScope.isVariableVisible(funcName))
                {
                    // Call by global reference
                    int index = globalScope.variableIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, GsDynamic(cast(double)index));
                }
                else
                {
                    // Call funcName directly
                    instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(funcName));
                }
                instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.LetStatement:
                string varName = node.value;
                node.programScope.defineVariable(varName);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ConstStatement:
                string varName = node.value;
                node.programScope.defineVariable(varName, true);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ExpressionStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.POP);
                break;
            
            case NodeType.ReturnStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.RET);
                break;
            
            case NodeType.PrintStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.PRINT);
                break;
            
            case NodeType.IndexAccessExpression:
                instructions ~= generate(node.children[0]); // array
                instructions ~= generate(node.children[1]); // index
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                break;
            
            case NodeType.IndexCallExpression:
                size_t numParameters = node.children.length - 2;
                foreach(child; node.children[2..$])
                    instructions ~= generate(child);
                instructions ~= generate(node.children[0]); // left expression
                instructions ~= generate(node.children[1]); // index expression
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.MemberPropertyAccessExpression:
                instructions ~= generate(node.children[0]);
                if (node.value == "length")
                    instructions ~= GsInstruction(GsInstructionType.LENGTH);
                else
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic(node.value));
                break;
            
            case NodeType.MemberCallExpression:
                size_t numParameters = node.children.length;
                
                foreach(child; node.children)
                        instructions ~= generate(child);
                
                if (builtins.canFind(node.value))
                {
                    // Use builtin
                    instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value));
                }
                else
                {
                    // Use member function
                    instructions ~= generate(node.children[0]); // identifier expression
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic(node.value));
                }
                
                instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.NewExpression:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.REUSE);
                break;
            
            case NodeType.ArgumentExpression:
                instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(node.value.to!double));
                break;
            
            case NodeType.ArgumentsArrayExpression:
                instructions ~= GsInstruction(GsInstructionType.LOAD_ARGS);
                break;
            
            case NodeType.IfStatement:
                string labelEndIf = getLabel();
                instructions ~= generate(node.children[0]); // condition
                instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, GsDynamic(labelEndIf));
                instructions ~= generate(node.children[1]); // if-block
                if (node.children.length > 2)
                {
                    string labelEndElse = getLabel();
                    instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelEndElse));
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndIf));
                    instructions ~= generate(node.children[2]); // else-block
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndElse));
                }
                else
                {
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndIf));
                }
                break;
            
            case NodeType.WhileStatement:
                string labelStartWhile = getLabel();
                string labelEndWhile = getLabel();
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartWhile));
                instructions ~= generate(node.children[0]); // condition
                instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, GsDynamic(labelEndWhile));
                instructions ~= generate(node.children[1]); // loop
                instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelStartWhile));
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndWhile));
                break;
            
            case NodeType.DoWhileStatement:
                string labelStartWhile = getLabel();
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartWhile));
                instructions ~= generate(node.children[1]); // loop
                instructions ~= generate(node.children[0]); // condition
                instructions ~= GsInstruction(GsInstructionType.JMP_IF, GsDynamic(labelStartWhile));
                break;
            
            case NodeType.ForStatement:
                string labelStartFor = getLabel();
                string labelEndFor = getLabel();
                instructions ~= generate(node.children[0]); // initialization
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartFor));
                instructions ~= generate(node.children[1]); // condition
                instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, GsDynamic(labelEndFor));
                instructions ~= generate(node.children[2]); // loop
                instructions ~= generate(node.children[3]); // advancement
                instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelStartFor));
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndFor));
                break;
            
            case NodeType.Function:
                // No-op
                break;
            
            case NodeType.Block:
                foreach(child; node.children)
                    instructions ~= generate(child);
                break;
            
            default:
                throw new Exception("Unknown ASTNode type: " ~ node.type.to!string);
        }
        
        return instructions;
    }
    
    void error(string msg)
    {
        // TODO: better error message, store file and line
        writeln("Codegen error: ", msg);
    }
    
    GsInstruction[] generate(GsProgram program)
    {
        globalScope = program.rootScope;
        GsInstruction[] output;
        
        size_t numFunctions = 0;
        
        // Store all functions in global variables
        foreach(modul; program.modulesInImportOrder)
        {
            ASTNode[] ast = modul.ast;
            
            foreach(ASTNode node; ast)
            {
                if (node.type == NodeType.Function)
                {
                    auto func = cast(ASTFunction)node;
                    
                    try
                    {
                        globalScope.defineVariable(func.name, true);
                        output ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.name));
                        output ~= GsInstruction(GsInstructionType.STORE_VAR, GsDynamic(cast(double)numFunctions));
                        numFunctions++;
                    }
                    catch(Exception e)
                    {
                        error(e.msg);
                        return [];
                    }
                }
            }
        }
        
        // Generate code for the global context
        foreach(modul; program.modulesInImportOrder)
        {
            ASTNode[] ast = modul.ast;
            
            foreach(ASTNode node; ast)
            {
                try
                {
                    output ~= generate(node);
                }
                catch(Exception e)
                {
                    error(e.msg);
                    return [];
                }
            }
        }
        
        // Terminate the global context
        output ~= GsInstruction(GsInstructionType.HALT);
        
        // Generate code for all functions
        foreach(modul; program.modulesInImportOrder)
        {
            ASTNode[] ast = modul.ast;
            
            // Free functions
            foreach(ASTNode node; ast)
            {
                if (node.type == NodeType.Function)
                {
                    auto func = cast(ASTFunction)node;
                    // TODO: qualified name
                    output ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(func.name));
                    
                    // Function body
                    try
                    {
                        output ~= generate(func.bodyBlock);
                    }
                    catch(Exception e)
                    {
                        error(e.msg);
                        return [];
                    }
                    
                    // Default return 0
                    output ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(cast(double)0.0));
                    output ~= GsInstruction(GsInstructionType.RET);
                }
            }
            
            // Anonymous fuctions
            foreach(ASTNode node; ast)
            {
                try
                {
                    auto instr = generateLambdas(node);
                    if (instr.length)
                        output ~= instr;
                }
                catch(Exception e)
                {
                    error(e.msg);
                    return [];
                }
            }
        }
        
        return output;
    }
}
