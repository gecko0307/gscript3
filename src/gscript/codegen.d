/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.codegen;

import std.variant;
import std.array;
import std.conv;
import gscript.parser;
import gscript.instruction_set;

class GsCodeGenerator
{
    GsInstructionType[string] binaryOperatorMap = [
        "+": GsInstructionType.ADD,
        "-": GsInstructionType.SUB,
        "*": GsInstructionType.MUL,
        "/": GsInstructionType.DIV,
        "%": GsInstructionType.MOD,
        "^^": GsInstructionType.POW,
        "&&": GsInstructionType.AND,
        "||": GsInstructionType.OR,
        "&": GsInstructionType.BITWISE_AND,
        "|": GsInstructionType.BITWISE_OR,
        "^": GsInstructionType.BITWISE_XOR,
        "~": GsInstructionType.CAT,
        "==": GsInstructionType.EQ,
        "!=": GsInstructionType.NEQ,
        "<": GsInstructionType.LESS,
        ">": GsInstructionType.GREATER,
        "<=": GsInstructionType.LESS_EQ,
        ">=": GsInstructionType.GREATER_EQ
    ];
    
    GsInstructionType[string] unaryOperatorMap = [
        "-": GsInstructionType.NEG,
        "!": GsInstructionType.NOT
    ];
    
    Scope globalScope;
    
    uint numLabels = 0;
    string getLabel()
    {
        return "label" ~ to!string(numLabels++);
    }
    
    this()
    {
    }
    
    protected GsInstruction[] generate(ASTNode node)
    {
        GsInstruction[] instructions;
        
        switch(node.type)
        {
            case NodeType.NumberLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(node.value.to!double));
                break;
            
            case NodeType.StringLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(node.value[1 .. $-1]));
                break;
            
            case NodeType.BooleanLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(node.value.to!bool));
                break;
            
            case NodeType.Identifier:
                string name = node.value;
                if (name == "global")
                {
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL);
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    int index = node.programScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, Variant(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, Variant(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    int index = globalScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, Variant(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.AssignExpression:
                ASTNode lhs = node.children[0];
                string name = lhs.value;
                ASTNode rhs = node.children[1];
                instructions ~= generate(rhs);
                if (lhs.type == NodeType.MemberPropertyAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // object
                    instructions ~= GsInstruction(GsInstructionType.SET, Variant(name));
                }
                else if (lhs.type == NodeType.IndexAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // array
                    instructions ~= generate(lhs.children[1]); // index
                    instructions ~= GsInstruction(GsInstructionType.INDEX_SET);
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    GsVariable* v = node.programScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.STORE_VAR, Variant(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.STORE_ARG, Variant(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    GsVariable* v = globalScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_STORE_VAR, Variant(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.BinaryExpression:
                string op = node.value;
                if (op == "&&")
                {
                    // Short-circuit for logical AND
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, Variant(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.AND);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, Variant(label));
                }
                else if (op == "||")
                {
                    // Short-circuit for logical OR
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF, Variant(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.OR);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, Variant(label));
                }
                else
                {
                    instructions ~= generate(node.children[0]);
                    instructions ~= generate(node.children[1]);
                    GsInstructionType* instrTypePtr = op in binaryOperatorMap;
                    if (instrTypePtr)
                        instructions ~= GsInstruction(*instrTypePtr);
                    else
                        throw new Exception("Unknown binary operator: " ~ op);
                }
                break;
            
            case NodeType.UnaryExpression:
                string op = node.value;
                auto operand = node.children[0];
                instructions ~= generate(operand);
                if (op != "+") // unary plus is a no-op
                {
                    GsInstructionType* instrTypePtr = op in unaryOperatorMap;
                    if (instrTypePtr)
                        instructions ~= GsInstruction(*instrTypePtr);
                    else
                        throw new Exception("Unknown unary operator: " ~ op);
                }
                break;
            
            case NodeType.FunctionCallExpression:
                // TODO: qualified name
                string funcName = node.value;
                size_t numParameters = node.children.length;
                foreach(child; node.children)
                    instructions ~= generate(child);
                if (node.programScope.isVariableVisible(funcName))
                {
                    // Call by reference
                    int index = node.programScope.variableIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, Variant(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(funcName))
                {
                    // Call by reference
                    int index = node.programScope.argumentIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, Variant(cast(double)index));
                }
                else if (globalScope.isVariableVisible(funcName))
                {
                    // Call by global reference
                    int index = globalScope.variableIndex(funcName);
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, Variant(cast(double)index));
                }
                else
                {
                    // Call funcName directly
                    instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(funcName));
                }
                instructions ~= GsInstruction(GsInstructionType.CALL, Variant(cast(double)numParameters));
                break;
            
            case NodeType.LetStatement:
                string varName = node.value;
                node.programScope.defineVariable(varName);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ConstStatement:
                string varName = node.value;
                node.programScope.defineVariable(varName, true);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ExpressionStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.POP);
                break;
            
            case NodeType.ReturnStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.RET);
                break;
            
            case NodeType.PrintStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.PRINT);
                break;
            
            case NodeType.IndexAccessExpression:
                instructions ~= generate(node.children[0]); // array
                instructions ~= generate(node.children[1]); // index
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                break;
            
            case NodeType.IndexCallExpression:
                size_t numParameters = node.children.length - 2;
                foreach(child; node.children[2..$])
                    instructions ~= generate(child);
                instructions ~= generate(node.children[0]); // left expression
                instructions ~= generate(node.children[1]); // index expression
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                instructions ~= GsInstruction(GsInstructionType.CALL, Variant(cast(double)numParameters));
                break;
            
            case NodeType.MemberPropertyAccessExpression:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.GET, Variant(node.value));
                break;
            
            case NodeType.MemberCallExpression:
                size_t numParameters = node.children.length - 1;
                foreach(child; node.children[1..$])
                    instructions ~= generate(child);
                instructions ~= generate(node.children[0]); // identifier expression
                instructions ~= GsInstruction(GsInstructionType.GET, Variant(node.value));
                instructions ~= GsInstruction(GsInstructionType.CALL, Variant(cast(double)numParameters));
                break;
            
            case NodeType.Function:
                // No-op
                break;
            
            case NodeType.Block:
                foreach(child; node.children)
                    instructions ~= generate(child);
                break;
            
            default:
                throw new Exception("Unknown ASTNode type: " ~ node.type.to!string);
        }
        
        return instructions;
    }

    GsInstruction[] generate(GsProgram program)
    {
        ASTNode[] ast = program.ast;
        
        globalScope = program.rootScope;
        
        GsInstruction[] instructions;
        
        GsInstruction[] functions;
        
        size_t numFunctions = 0;
        
        // Store functions in global variables
        foreach(ASTNode node; ast)
        {
            if (node.type == NodeType.Function)
            {
                auto func = cast(ASTFunction)node;
                
                globalScope.defineVariable(func.name, true);
                instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(func.name));
                instructions ~= GsInstruction(GsInstructionType.STORE_VAR, Variant(cast(double)numFunctions));
                numFunctions++;
            }
        }
        
        // Generate code for the global context
        foreach(ASTNode node; ast)
        {
            instructions ~= generate(node);
        }
        
        instructions ~= GsInstruction(GsInstructionType.HALT);
        
        // Generate code for functions
        foreach(ASTNode node; ast)
        {
            if (node.type == NodeType.Function)
            {
                auto func = cast(ASTFunction)node;
                // TODO: qualified name
                instructions ~= GsInstruction(GsInstructionType.LABEL, Variant(func.name));
                
                // Function body
                instructions ~= generate(func.bodyBlock);
                
                // Default return 0
                instructions ~= GsInstruction(GsInstructionType.PUSH, Variant(cast(double)0.0));
                instructions ~= GsInstruction(GsInstructionType.RET);
            }
        }
        
        return instructions;
    }
}
