/*
Copyright (c) 2025 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module gscript.codegen;

import std.stdio;
import std.array;
import std.conv;
import std.algorithm;

import gscript.parser;
import gscript.instructions;
import gscript.dynamic;
import gscript.arena;

class GsCodeGenerator
{
    GsInstructionType[string] binaryOperatorMap = [
        "+": GsInstructionType.ADD,
        "-": GsInstructionType.SUB,
        "*": GsInstructionType.MUL,
        "/": GsInstructionType.DIV,
        "%": GsInstructionType.MOD,
        "^^": GsInstructionType.POW,
        "&&": GsInstructionType.AND,
        "||": GsInstructionType.OR,
        "&": GsInstructionType.BITWISE_AND,
        "|": GsInstructionType.BITWISE_OR,
        "^": GsInstructionType.BITWISE_XOR,
        "~": GsInstructionType.CAT,
        "==": GsInstructionType.EQ,
        "!=": GsInstructionType.NEQ,
        "<": GsInstructionType.LESS,
        ">": GsInstructionType.GREATER,
        "<=": GsInstructionType.LESS_EQ,
        ">=": GsInstructionType.GREATER_EQ,
        ":": GsInstructionType.TYPE_IS
    ];
    
    GsInstructionType[string] unaryOperatorMap = [
        "-": GsInstructionType.NEG,
        "!": GsInstructionType.NOT
    ];
    
    GsDynamic[string] constants = [
        "Null": GsDynamic(cast(double)GsDynamicType.Null),
        "Number": GsDynamic(cast(double)GsDynamicType.Number),
        "String": GsDynamic(cast(double)GsDynamicType.String),
        "Array": GsDynamic(cast(double)GsDynamicType.Array),
        "Object": GsDynamic(cast(double)GsDynamicType.Object),
        "NativeMethod": GsDynamic(cast(double)GsDynamicType.NativeMethod),
        "NativeFunction": GsDynamic(cast(double)GsDynamicType.NativeFunction),
        "Error": GsDynamic(cast(double)GsDynamicType.Error)
    ];
    
    string[] builtins = [
        "remove", "removeFront", "removeBack", "insert", "slice"
    ];
    
    GsModule currentModule;
    
    auto ref macros()
    {
        return currentModule.macros;
    }
    
    Scope globalScope;
    
    uint numLabels = 0;
    string getLabel()
    {
        return "label" ~ to!string(numLabels++);
    }
    
    this()
    {
    }
    
    protected GsInstruction[] generateLambdas(ASTNode node)
    {
        GsInstruction[] instructions;
        
        if (node.type == NodeType.FunctionLiteral)
        {
            auto func = cast(ASTFunctionLiteral)node;
            
            // Function label
            instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(func.label));
            
            // Function body
            instructions ~= generate(func.bodyBlock);
            
            // Return null by default
            instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic());
            instructions ~= GsInstruction(GsInstructionType.RET);
        }
        else if (node.type == NodeType.Function)
        {
            auto func = cast(ASTFunction)node;
            
            auto instr = generateLambdas(func.bodyBlock);
            if (instr.length)
                instructions ~= instr;
        }
        else
        {
            foreach(child; node.children)
            {
                auto instr = generateLambdas(child);
                if (instr.length)
                    instructions ~= instr;
            }
        }
        
        return instructions;
    }
    
    protected GsInstruction[] generate(ASTNode node)
    {
        GsInstruction[] instructions;
        
        switch(node.type)
        {
            case NodeType.NullLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic());
                break;
            
            case NodeType.ErrorLiteral:
                auto params = node.children[0];
                if (params.children.length)
                    instructions ~= generate(params.children[0]);
                else
                    instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(""));
                instructions ~= GsInstruction(GsInstructionType.ERROR);
                break;
            
            case NodeType.NumberLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value.to!double));
                break;
            
            case NodeType.StringLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value[1 .. $-1]));
                break;
            
            case NodeType.BooleanLiteral:
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.value.to!bool));
                break;
            
            case NodeType.ArrayLiteral:
                foreach(child; node.children)
                    instructions ~= generate(child);
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(node.children.length));
                uint region = !node.sharedAccess;
                instructions ~= GsInstruction(GsInstructionType.ARRAY, GsDynamic(cast(double)region));
                break;
            
            case NodeType.ObjectLiteral:
                uint region = !node.sharedAccess;
                instructions ~= GsInstruction(GsInstructionType.NEW, GsDynamic(cast(double)region));
                foreach(child; node.children)
                {
                    string key = child.value;
                    instructions ~= generate(child.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.INIT_SET, GsDynamic(key));
                }
                break;
            
            case NodeType.FunctionLiteral:
                auto func = cast(ASTFunctionLiteral)node;
                func.label = getLabel();
                instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.label));
                break;
            
            case NodeType.Identifier:
                string name = node.value;
                if (name == "global")
                {
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL);
                }
                else if (name in constants)
                {
                    instructions ~= GsInstruction(GsInstructionType.PUSH, constants[name]);
                }
                else if (name in macros)
                {
                    auto macroExpr = macros[name];
                    if (macroExpr.type == NodeType.FunctionLiteral)
                    {
                        auto func = cast(ASTFunctionLiteral)macroExpr;
                        instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.label));
                    }
                    else
                    {
                        instructions ~= generate(macros[name]);
                    }
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    int index = node.programScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, GsDynamic(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    int index = globalScope.variableIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, GsDynamic(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.AssignExpression:
                ASTNode lhs = node.children[0];
                string name = lhs.value;
                ASTNode rhs = node.children[1];
                if (node.sharedAccess)
                    rhs.sharedAccess = node.sharedAccess;
                instructions ~= generate(rhs);
                if (lhs.type == NodeType.MemberPropertyAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // object
                    instructions ~= GsInstruction(GsInstructionType.SET, GsDynamic(name));
                }
                else if (lhs.type == NodeType.IndexAccessExpression)
                {
                    instructions ~= generate(lhs.children[0]); // array
                    instructions ~= generate(lhs.children[1]); // index
                    instructions ~= GsInstruction(GsInstructionType.INDEX_SET);
                }
                else if (node.programScope.isVariableVisible(name))
                {
                    GsVariable* v = node.programScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.STORE_VAR, GsDynamic(cast(double)index));
                }
                else if (node.programScope.isArgumentVisible(name))
                {
                    int index = node.programScope.argumentIndex(name);
                    instructions ~= GsInstruction(GsInstructionType.STORE_ARG, GsDynamic(cast(double)index));
                }
                else if (globalScope.isVariableVisible(name))
                {
                    GsVariable* v = globalScope.getVariable(name);
                    if (v.isConst && v.isInitialized)
                        throw new Exception("Assignment to constant variable \"" ~ name ~ "\"");
                    
                    v.isInitialized = true;
                    int index = v.index;
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL_STORE_VAR, GsDynamic(cast(double)index));
                }
                else
                {
                    throw new Exception("Undefined variable \"" ~ name ~ "\"");
                }
                break;
            
            case NodeType.BinaryExpression:
                string op = node.value;
                if (op == "&&")
                {
                    // Short-circuit for logical AND
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF_NOT, GsDynamic(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.AND);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(label));
                }
                else if (op == "||")
                {
                    // Short-circuit for logical OR
                    string label = getLabel();
                    instructions ~= generate(node.children[0]);
                    instructions ~= GsInstruction(GsInstructionType.JMP_IF, GsDynamic(label));
                    instructions ~= generate(node.children[1]);
                    instructions ~= GsInstruction(GsInstructionType.OR);
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(label));
                }
                else
                {
                    instructions ~= generate(node.children[0]);
                    instructions ~= generate(node.children[1]);
                    GsInstructionType* instrTypePtr = op in binaryOperatorMap;
                    if (instrTypePtr)
                    {
                        uint region = !node.sharedAccess;
                        instructions ~= GsInstruction(*instrTypePtr, GsDynamic(cast(double)region));
                    }
                    else
                        throw new Exception("Unknown binary operator: " ~ op);
                }
                break;
            
            case NodeType.UnaryExpression:
                string op = node.value;
                auto operand = node.children[0];
                instructions ~= generate(operand);
                if (op != "+") // unary plus is a no-op
                {
                    GsInstructionType* instrTypePtr = op in unaryOperatorMap;
                    if (instrTypePtr)
                        instructions ~= GsInstruction(*instrTypePtr);
                    else
                        throw new Exception("Unknown unary operator: " ~ op);
                }
                break;
            
            case NodeType.FunctionCallExpression:
                string funcName = node.value;
                if (funcName in macros)
                {
                    // Call by macro substitution
                    auto macroExpr = macros[funcName];
                    if (macroExpr.type == NodeType.FunctionLiteral)
                    {
                        auto func = cast(ASTFunctionLiteral)macroExpr;
                        size_t numParameters = node.children.length;
                        foreach(child; node.children)
                            instructions ~= generate(child);
                        instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.label));
                        instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                    }
                    else if (macroExpr.type == NodeType.MemberPropertyAccessExpression)
                    {
                        ASTNode leftExpr = macroExpr.children[0];
                        ASTNode newNode = new ASTNode(NodeType.MemberCallExpression, macroExpr.value, leftExpr ~ node.children);
                        newNode.programScope = node.programScope;
                        instructions ~= generate(newNode);
                    }
                    else if (macroExpr.type == NodeType.Identifier && macroExpr.value != funcName)
                    {
                        ASTNode newNode = new ASTNode(NodeType.FunctionCallExpression, macroExpr.value, node.children);
                        newNode.programScope = node.programScope;
                        instructions ~= generate(newNode);
                    }
                    else
                    {
                        throw new Exception("Cannot substitute a function call with macro \"" ~ funcName ~ "\"");
                    }
                }
                else
                {
                    size_t numParameters = node.children.length;
                    foreach(child; node.children)
                        instructions ~= generate(child);
                    if (node.programScope.isVariableVisible(funcName))
                    {
                        // Call by reference
                        int index = node.programScope.variableIndex(funcName);
                        instructions ~= GsInstruction(GsInstructionType.LOAD_VAR, GsDynamic(cast(double)index));
                    }
                    else if (node.programScope.isArgumentVisible(funcName))
                    {
                        // Call by reference
                        int index = node.programScope.argumentIndex(funcName);
                        instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(cast(double)index));
                    }
                    else if (globalScope.isVariableVisible(funcName))
                    {
                        // Call by global reference
                        int index = globalScope.variableIndex(funcName);
                        instructions ~= GsInstruction(GsInstructionType.GLOBAL_LOAD_VAR, GsDynamic(cast(double)index));
                    }
                    else
                    {
                        throw new Exception("Undefined function \"" ~ funcName ~ "\"");
                        
                        // Call funcName directly
                        //instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(funcName));
                    }
                    instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                }
                break;
            
            case NodeType.SpawnExpression:
                auto funcCall = node.children[0];
                auto spawnParams = node.children[1];
                size_t numParameters = 0;
                if (spawnParams.children.length > 0)
                {
                    // Push function parameters
                    numParameters = spawnParams.children.length - 1;
                    foreach(child; spawnParams.children[1..$])
                        instructions ~= generate(child);
                    // Use first spawn parameter as a payload object
                    instructions ~= generate(spawnParams.children[0]);
                }
                else
                {
                    // Implicitly create a new payload object
                    instructions ~= GsInstruction(GsInstructionType.NEW, GsDynamic(1.0));
                }
                instructions ~= generate(funcCall);
                instructions ~= GsInstruction(GsInstructionType.SPAWN, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.AwaitExpression:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.AWAIT);
                break;
            
            case NodeType.SyncExpression:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.SYNC);
                break;
            
            case NodeType.EscapeExpression:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.ESCAPE);
                break;
            
            case NodeType.LetStatement:
                string varName = node.value;
                if (nameIsDefined(node.programScope, varName))
                    throw new Exception("Redefinition of \"" ~ varName ~ "\"");
                node.programScope.defineVariable(varName);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ConstStatement:
                string varName = node.value;
                if (nameIsDefined(node.programScope, varName))
                    throw new Exception("Redefinition of \"" ~ varName ~ "\"");
                node.programScope.defineVariable(varName, true);
                instructions ~= generate(node.children[0]);
                break;
            
            case NodeType.ExpressionStatement:
                if (node.sharedAccess)
                    node.children[0].sharedAccess = node.sharedAccess;
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.POP);
                break;
            
            case NodeType.ReturnStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.RET);
                break;
            
            case NodeType.YieldStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.YIELD);
                break;
            
            case NodeType.PrintStatement:
                instructions ~= generate(node.children[0]);
                instructions ~= GsInstruction(GsInstructionType.PRINT);
                break;
            
            case NodeType.IndexAccessExpression:
                instructions ~= generate(node.children[0]); // array
                instructions ~= generate(node.children[1]); // index
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                break;
            
            case NodeType.IndexCallExpression:
                size_t numParameters = node.children.length - 2;
                foreach(child; node.children[2..$])
                    instructions ~= generate(child);
                instructions ~= generate(node.children[0]); // left expression
                instructions ~= generate(node.children[1]); // index expression
                instructions ~= GsInstruction(GsInstructionType.INDEX_GET);
                instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.MemberPropertyAccessExpression:
                instructions ~= generate(node.children[0]);
                if (node.value == "length")
                    instructions ~= GsInstruction(GsInstructionType.LENGTH);
                else
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic(node.value));
                break;
            
            case NodeType.MemberCallExpression:
                size_t numParameters = node.children.length;
                
                if (builtins.canFind(node.value))
                {
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL);
                    numParameters++;
                }
                
                foreach(child; node.children)
                    instructions ~= generate(child);
                
                if (builtins.canFind(node.value))
                {
                    // Use builtin
                    instructions ~= GsInstruction(GsInstructionType.GLOBAL);
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic("builtins"));
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic(node.value));
                    instructions ~= GsInstruction(GsInstructionType.BORROW);
                }
                else
                {
                    // Use member function
                    instructions ~= generate(node.children[0]); // identifier expression
                    instructions ~= GsInstruction(GsInstructionType.GET, GsDynamic(node.value));
                }
                
                instructions ~= GsInstruction(GsInstructionType.CALL, GsDynamic(cast(double)numParameters));
                break;
            
            case NodeType.NewExpression:
                instructions ~= generate(node.children[0]);
                uint region = !node.sharedAccess;
                instructions ~= GsInstruction(GsInstructionType.REUSE, GsDynamic(cast(double)region));
                break;
            
            case NodeType.ArrayExpression:
                auto params = node.children[0];
                if (params.children.length)
                {
                    // Default type
                    if (params.children.length > 1)
                        instructions ~= generate(params.children[1]);
                    else
                        instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic());
                    
                    // Array length
                    instructions ~= generate(params.children[0]);
                }
                else
                {
                    instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic());
                    instructions ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(0.0));
                }
                uint region = !node.sharedAccess;
                instructions ~= GsInstruction(GsInstructionType.ARRAY_DEF, GsDynamic(cast(double)region));
                break;
            
            case NodeType.ArgumentExpression:
                instructions ~= GsInstruction(GsInstructionType.LOAD_ARG, GsDynamic(node.value.to!double));
                break;
            
            case NodeType.ArgumentsArrayExpression:
                instructions ~= GsInstruction(GsInstructionType.LOAD_ARGS);
                break;
            
            case NodeType.IfStatement:
                string labelEndIf = getLabel();
                instructions ~= generate(node.children[0]); // condition
                instructions ~= GsInstruction(GsInstructionType.JMPPOP_IF_NOT, GsDynamic(labelEndIf));
                instructions ~= GsInstruction(GsInstructionType.POP);
                instructions ~= generate(node.children[1]); // if-block
                if (node.children.length > 2)
                {
                    string labelEndElse = getLabel();
                    instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelEndElse));
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndIf));
                    instructions ~= generate(node.children[2]); // else-block
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndElse));
                }
                else
                {
                    instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndIf));
                }
                break;
            
            case NodeType.WhileStatement:
                string labelStartWhile = getLabel();
                string labelEndWhile = getLabel();
                auto condition = node.children[0];
                auto loopBlock = cast(ASTBlock)node.children[1];
                loopBlock.programScope.breakLabel = labelEndWhile;
                loopBlock.programScope.continueLabel = labelStartWhile;
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartWhile));
                instructions ~= generate(condition);
                instructions ~= GsInstruction(GsInstructionType.JMPPOP_IF_NOT, GsDynamic(labelEndWhile));
                instructions ~= GsInstruction(GsInstructionType.POP);
                instructions ~= generate(loopBlock);
                instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelStartWhile));
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndWhile));
                break;
            
            case NodeType.DoWhileStatement:
                string labelStartWhile = getLabel();
                string labelEndWhile = getLabel();
                auto condition = node.children[0];
                auto loopBlock = cast(ASTBlock)node.children[1];
                loopBlock.programScope.breakLabel = labelEndWhile;
                loopBlock.programScope.continueLabel = labelStartWhile;
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartWhile));
                instructions ~= generate(loopBlock); // loop
                instructions ~= generate(condition); // condition
                instructions ~= GsInstruction(GsInstructionType.JMPPOP_IF, GsDynamic(labelStartWhile));
                instructions ~= GsInstruction(GsInstructionType.POP);
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndWhile));
                break;
            
            case NodeType.ForStatement:
                string labelStartFor = getLabel();
                string labelEndFor = getLabel();
                auto initialization = node.children[0];
                auto condition = node.children[1];
                auto loopBlock = cast(ASTBlock)node.children[2];
                auto advancement = node.children[3];
                loopBlock.programScope.breakLabel = labelEndFor;
                loopBlock.programScope.continueLabel = labelStartFor;
                instructions ~= generate(initialization); // initialization
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelStartFor));
                instructions ~= generate(condition); // condition
                instructions ~= GsInstruction(GsInstructionType.JMPPOP_IF_NOT, GsDynamic(labelEndFor));
                instructions ~= GsInstruction(GsInstructionType.POP);
                instructions ~= generate(loopBlock); // loop
                instructions ~= generate(advancement); // advancement
                instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(labelStartFor));
                instructions ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(labelEndFor));
                break;
            
            case NodeType.BreakStatement:
                string breakLabel = node.getBreakLabel();
                if (breakLabel.length)
                    instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(breakLabel));
                else
                    throw new Exception("Illegal \"break\"");
                break;
            
            case NodeType.ContinueStatement:
                string continueLabel = node.getContinueLabel();
                if (continueLabel.length)
                    instructions ~= GsInstruction(GsInstructionType.JMP, GsDynamic(continueLabel));
                else
                    throw new Exception("Illegal \"continue\"");
                break;
            
            case NodeType.MacroDefineStatement:
                if (nameIsDefined(node.programScope, node.value))
                {
                    throw new Exception("Redefinition of \"" ~ node.value ~ "\"");
                }
                else
                {
                    GsDynamic eval = evaluate(node.children[0]);
                    if (eval.type == GsDynamicType.Number)
                        macros[node.value] = new ASTNode(NodeType.NumberLiteral, eval.asNumber.to!string);
                    else if (eval.type == GsDynamicType.String)
                        macros[node.value] = new ASTNode(NodeType.StringLiteral, "\"" ~ eval.asString ~ "\"");
                    else
                    {
                        auto macroExpr = node.children[0];
                        macros[node.value] = macroExpr;
                        if (macroExpr.type == NodeType.FunctionLiteral)
                        {
                            auto func = cast(ASTFunctionLiteral)macroExpr;
                            func.label = getLabel();
                        }
                    }
                }
                break;
            
            case NodeType.Function:
                // No-op
                break;
            
            case NodeType.Block:
                foreach(child; node.children)
                    instructions ~= generate(child);
                break;
            
            default:
                throw new Exception("Unknown ASTNode type: " ~ node.type.to!string);
        }
        
        return instructions;
    }
    
    GsDynamic evaluate(ASTNode node)
    {
        switch(node.type)
        {
            case NodeType.Identifier:
                if (node.value in macros)
                    return evaluate(macros[node.value]);
                else
                    return GsDynamic();
            
            case NodeType.NumberLiteral:
                return GsDynamic(node.value.to!double);
            
            case NodeType.StringLiteral:
                return GsDynamic(node.value[1 .. $-1]);
                break;
            
            case NodeType.BooleanLiteral:
                return GsDynamic(cast(double)node.value.to!bool);
            
            case NodeType.BinaryExpression:
                string op = node.value;
                GsDynamic v1 = evaluate(node.children[0]);
                GsDynamic v2 = evaluate(node.children[1]);
                if (op == ":")
                {
                    if (v2.type == GsDynamicType.Number)
                        return GsDynamic(cast(double)(v1.type == cast(uint)v2.asNumber));
                    else
                        return GsDynamic();
                }
                
                if (v1.type == GsDynamicType.Number && v2.type == GsDynamicType.Number)
                {
                    if (op == "+")
                        return GsDynamic(v1.asNumber + v2.asNumber);
                    else if (op == "-")
                        return GsDynamic(v1.asNumber - v2.asNumber);
                    else if (op == "*")
                        return GsDynamic(v1.asNumber * v2.asNumber);
                    else if (op == "/")
                        return GsDynamic(v1.asNumber / v2.asNumber);
                    else if (op == "*")
                        return GsDynamic(v1.asNumber * v2.asNumber);
                    else if (op == "%")
                        return GsDynamic(v1.asNumber % v2.asNumber);
                    else if (op == "^^")
                        return GsDynamic(v1.asNumber ^^ v2.asNumber);
                    else if (op == "&&")
                        return GsDynamic(cast(double)(cast(bool)v1.asNumber && cast(bool)v2.asNumber));
                    else if (op == "||")
                        return GsDynamic(cast(double)(cast(bool)v1.asNumber || cast(bool)v2.asNumber));
                    else if (op == "&")
                        return GsDynamic(cast(double)(cast(long)v1.asNumber & cast(long)v2.asNumber));
                    else if (op == "|")
                        return GsDynamic(cast(double)(cast(long)v1.asNumber | cast(long)v2.asNumber));
                    else if (op == "^")
                        return GsDynamic(cast(double)(cast(long)v1.asNumber ^ cast(long)v2.asNumber));
                    else if (op == "==")
                        return GsDynamic(cast(double)(v1.asNumber == v2.asNumber));
                    else if (op == "!=")
                        return GsDynamic(cast(double)(v1.asNumber != v2.asNumber));
                    else if (op == "<")
                        return GsDynamic(cast(double)(v1.asNumber < v2.asNumber));
                    else if (op == ">")
                        return GsDynamic(cast(double)(v1.asNumber > v2.asNumber));
                    else if (op == "<=")
                        return GsDynamic(cast(double)(v1.asNumber <= v2.asNumber));
                    else if (op == ">=")
                        return GsDynamic(cast(double)(v1.asNumber >= v2.asNumber));
                    else if (op == ":")
                        return GsDynamic(cast(double)(v1.asNumber >= v2.asNumber));
                    else
                        return GsDynamic();
                }
                else if (v1.type == GsDynamicType.String && v2.type == GsDynamicType.String)
                {
                    if (op == "~")
                        return GsDynamic(v1.asString ~ v2.asString);
                    else
                        return GsDynamic();
                }
                else
                    return GsDynamic();
            
            default:
                return GsDynamic();
        }
    }
    
    bool nameIsDefined(Scope localScope, string name)
    {
        return
            name == "global" ||
            name in constants ||
            name in macros ||
            localScope.isVariableVisible(name) ||
            localScope.isArgumentVisible(name) ||
            globalScope.isVariableVisible(name);
    }
    
    void error(string msg)
    {
        // TODO: better error message, store file and line
        writeln("Codegen error: ", msg);
    }
    
    GsInstruction[] generate(GsProgram program)
    {
        globalScope = program.rootScope;
        GsInstruction[] output;
        
        size_t numFunctions = 0;
        
        // Store all functions in global variables
        foreach(modul; program.modulesInImportOrder)
        {
            currentModule = modul;
            ASTNode[] ast = modul.ast;
            
            foreach(ASTNode node; ast)
            {
                if (node.type == NodeType.Function)
                {
                    auto func = cast(ASTFunction)node;
                    
                    try
                    {
                        if (nameIsDefined(func.programScope, func.value))
                        {
                            throw new Exception("Redefinition of \"" ~ func.value ~ "\"");
                        }
                        else
                        {
                            globalScope.defineVariable(func.name, true);
                            output ~= GsInstruction(GsInstructionType.PUSH, GsDynamic(func.name));
                            output ~= GsInstruction(GsInstructionType.STORE_VAR, GsDynamic(cast(double)numFunctions));
                            numFunctions++;
                        }
                    }
                    catch(Exception e)
                    {
                        error(e.msg);
                        return [];
                    }
                }
            }
        }
        
        // Generate code for the global context
        foreach(modul; program.modulesInImportOrder)
        {
            currentModule = modul;
            ASTNode[] ast = modul.ast;
            
            foreach(ASTNode node; ast)
            {
                try
                {
                    output ~= generate(node);
                }
                catch(Exception e)
                {
                    error(e.msg);
                    return [];
                }
            }
        }
        
        // Terminate the global context
        output ~= GsInstruction(GsInstructionType.HALT);
        
        // Generate code for all functions
        foreach(modul; program.modulesInImportOrder)
        {
            currentModule = modul;
            ASTNode[] ast = modul.ast;
            
            // Free functions
            foreach(ASTNode node; ast)
            {
                if (node.type == NodeType.Function)
                {
                    auto func = cast(ASTFunction)node;
                    
                    output ~= GsInstruction(GsInstructionType.LABEL, GsDynamic(func.name));
                    
                    // Function body
                    try
                    {
                        output ~= generate(func.bodyBlock);
                    }
                    catch(Exception e)
                    {
                        error(e.msg);
                        return [];
                    }
                    
                    // Return null by default
                    output ~= GsInstruction(GsInstructionType.PUSH, GsDynamic());
                    output ~= GsInstruction(GsInstructionType.RET);
                }
            }
            
            // Anonymous fuctions
            foreach(ASTNode node; ast)
            {
                try
                {
                    auto instr = generateLambdas(node);
                    if (instr.length)
                        output ~= instr;
                }
                catch(Exception e)
                {
                    error(e.msg);
                    return [];
                }
            }
        }
        
        output ~= GsInstruction(GsInstructionType.HALT);
        
        return output;
    }
}
